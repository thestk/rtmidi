<HTML>
<HEAD>
<TITLE>The RtMidi Tutorial</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
<HR>
<!-- Generated by Doxygen 1.4.4 -->
<h1>The <a class="el" href="classRtMidi.html">RtMidi</a> Tutorial </h1>
<p>
<center><a class="el" href="index.html#intro">Introduction</a> &nbsp;&nbsp; <a class="el" href="index.html#download">Download</a> &nbsp;&nbsp; <a class="el" href="index.html#start">Getting Started</a> &nbsp;&nbsp; <a class="el" href="index.html#error">Error Handling</a> &nbsp;&nbsp; <a class="el" href="index.html#probing">Probing Ports</a> &nbsp;&nbsp; <a class="el" href="index.html#output">MIDI Output</a> &nbsp;&nbsp; <a class="el" href="index.html#input">MIDI Input</a> &nbsp;&nbsp; <a class="el" href="index.html#virtual">Virtual Ports</a> &nbsp;&nbsp; <a class="el" href="index.html#compiling">Compiling</a> &nbsp;&nbsp; <a class="el" href="index.html#debug">Debugging</a> &nbsp;&nbsp; <a class="el" href="index.html#apinotes">API Notes</a> &nbsp;&nbsp; <a class="el" href="index.html#acknowledge">Acknowledgements</a> &nbsp;&nbsp; <a class="el" href="index.html#license">License</a></center><h2><a class="anchor" name="intro">
Introduction</a></h2>
<a class="el" href="classRtMidi.html">RtMidi</a> is a set of C++ classes (<a class="el" href="classRtMidiIn.html">RtMidiIn</a> and <a class="el" href="classRtMidiOut.html">RtMidiOut</a>) that provides a common API (Application Programming Interface) for realtime MIDI input/output across Linux (ALSA), Macintosh OS X, SGI, and Windows (Multimedia Library) operating systems. <a class="el" href="classRtMidi.html">RtMidi</a> significantly simplifies the process of interacting with computer MIDI hardware and software. It was designed with the following goals:<p>
<ul>
<li>
object oriented C++ design </li>
<li>
simple, common API across all supported platforms </li>
<li>
only two header files and one source file for easy inclusion in programming projects </li>
<li>
MIDI device enumeration </li>
</ul>
<p>
MIDI input and output functionality are separated into two classes, <a class="el" href="classRtMidiIn.html">RtMidiIn</a> and <a class="el" href="classRtMidiOut.html">RtMidiOut</a>. Each class instance supports only a single MIDI connection. <a class="el" href="classRtMidi.html">RtMidi</a> does not provide timing functionality (i.e., output messages are sent immediately). Input messages are timestamped with delta times in seconds (via a <code>double</code> floating point type). MIDI data is passed to the user as raw bytes using an std::vector&lt;unsigned char&gt;.<h2><a class="anchor" name="download">
Download</a></h2>
Latest Release (9 March 2006): <a href="http://music.mcgill.ca/~gary/rtmidi/release/rtmidi-1.0.6.tar.gz">Version 1.0.6</a><h2><a class="anchor" name="start">
Getting Started</a></h2>
The first thing that must be done when using <a class="el" href="classRtMidi.html">RtMidi</a> is to create an instance of the <a class="el" href="classRtMidiIn.html">RtMidiIn</a> or <a class="el" href="classRtMidiOut.html">RtMidiOut</a> subclasses. <a class="el" href="classRtMidi.html">RtMidi</a> is an abstract base class, which itself cannot be instantiated. Each default constructor attempts to establish any necessary "connections" with the underlying MIDI system. <a class="el" href="classRtMidi.html">RtMidi</a> uses C++ exceptions to report errors, necessitating try/catch blocks around many member functions. An <a class="el" href="classRtError.html">RtError</a> can be thrown during instantiation in some circumstances. A warning message may also be reported if no MIDI devices are found during instantiation. The <a class="el" href="classRtMidi.html">RtMidi</a> classes have been designed to work with "hot pluggable" or virtual (software) MIDI devices, making it possible to connect to MIDI devices that may not have been present when the classes were instantiated. The following code example demonstrates default object construction and destruction:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "RtMidi.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html">RtMidiIn</a> *midiin = 0;

  <span class="comment">// RtMidiIn constructor</span>
  <span class="keywordflow">try</span> {
    midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html">RtMidiIn</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
    <span class="comment">// Handle the exception here</span>
    error.<a class="code" href="classRtError.html#a2">printMessage</a>();
  }

  <span class="comment">// Clean up</span>
  <span class="keyword">delete</span> midiin;
}
</pre></div><p>
Obviously, this example doesn't demonstrate any of the real functionality of <a class="el" href="classRtMidi.html">RtMidi</a>. However, all uses of <a class="el" href="classRtMidi.html">RtMidi</a> must begin with construction and must end with class destruction. Further, it is necessary that all class methods that can throw a C++ exception be called within a try/catch block.<h2><a class="anchor" name="error">
Error Handling</a></h2>
<a class="el" href="classRtMidi.html">RtMidi</a> uses a C++ exception handler called <a class="el" href="classRtError.html">RtError</a>, which is declared and defined in <a class="el" href="RtError_8h-source.html">RtError.h</a>. The <a class="el" href="classRtError.html">RtError</a> class is quite simple but it does allow errors to be "caught" by <a class="el" href="classRtError.html#w11">RtError::Type</a>. Many <a class="el" href="classRtMidi.html">RtMidi</a> methods can "throw" an <a class="el" href="classRtError.html">RtError</a>, most typically if a driver error occurs or an invalid function argument is specified. There are a number of cases within <a class="el" href="classRtMidi.html">RtMidi</a> where warning messages may be displayed but an exception is not thrown. There is a protected <a class="el" href="classRtMidi.html">RtMidi</a> method, error(), which can be modified to globally control how these messages are handled and reported. By default, error messages are not automatically displayed in <a class="el" href="classRtMidi.html">RtMidi</a> unless the preprocessor definition __RTMIDI_DEBUG__ is defined. Messages associated with caught exceptions can be displayed with, for example, the <a class="el" href="classRtError.html#a2">RtError::printMessage()</a> function.<h2><a class="anchor" name="probing">
Probing Ports</a></h2>
A programmer may wish to query the available MIDI ports before deciding which to use. The following example outlines how this can be done.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// midiinfo.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "RtMidi.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html">RtMidiIn</a>  *midiin = 0;
  <a class="code" href="classRtMidiOut.html">RtMidiOut</a> *midiout = 0;

  <span class="comment">// RtMidiIn constructor</span>
  <span class="keywordflow">try</span> {
    midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html">RtMidiIn</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
    error.<a class="code" href="classRtError.html#a2">printMessage</a>();
    exit(EXIT_FAILURE);
  }

  <span class="comment">// Check inputs.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a7">getPortCount</a>();
  std::cout &lt;&lt; <span class="stringliteral">"\nThere are "</span> &lt;&lt; nPorts &lt;&lt; <span class="stringliteral">" MIDI input sources available.\n"</span>;
  std::string portName;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nPorts; i++ ) {
    <span class="keywordflow">try</span> {
      portName = midiin-&gt;<a class="code" href="classRtMidiIn.html#a8">getPortName</a>(i);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
      error.<a class="code" href="classRtError.html#a2">printMessage</a>();
      <span class="keywordflow">goto</span> cleanup;
    }
    std::cout &lt;&lt; <span class="stringliteral">"  Input Port #"</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; portName &lt;&lt; <span class="charliteral">'\n'</span>;
  }

  <span class="comment">// RtMidiOut constructor</span>
  <span class="keywordflow">try</span> {
    midiout = <span class="keyword">new</span> <a class="code" href="classRtMidiOut.html">RtMidiOut</a>();
  }
  <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
    error.<a class="code" href="classRtError.html#a2">printMessage</a>();
    exit(EXIT_FAILURE);
  }

  <span class="comment">// Check outputs.</span>
  nPorts = midiout-&gt;<a class="code" href="classRtMidiOut.html#a5">getPortCount</a>();
  std::cout &lt;&lt; <span class="stringliteral">"\nThere are "</span> &lt;&lt; nPorts &lt;&lt; <span class="stringliteral">" MIDI output ports available.\n"</span>;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nPorts; i++ ) {
    <span class="keywordflow">try</span> {
      portName = midiout-&gt;<a class="code" href="classRtMidiOut.html#a6">getPortName</a>(i);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classRtError.html">RtError</a> &amp;error) {
      error.<a class="code" href="classRtError.html#a2">printMessage</a>();
      <span class="keywordflow">goto</span> cleanup;
    }
    std::cout &lt;&lt; <span class="stringliteral">"  Output Port #"</span> &lt;&lt; i+1 &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; portName &lt;&lt; <span class="charliteral">'\n'</span>;
  }
  std::cout &lt;&lt; <span class="charliteral">'\n'</span>;

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;
  <span class="keyword">delete</span> midiout;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" name="output">
MIDI Output</a></h2>
The <a class="el" href="classRtMidiOut.html">RtMidiOut</a> class provides simple functionality to immediately send messages over a MIDI connection. No timing functionality is provided.<p>
In the following example, we omit necessary error checking and details regarding OS-dependent sleep functions. For a complete example, see the <code>midiout.cpp</code> program in the <code>tests</code> directory.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// midiout.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "RtMidi.h"</span>

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiOut.html">RtMidiOut</a> *midiout = <span class="keyword">new</span> <a class="code" href="classRtMidiOut.html">RtMidiOut</a>();
  std::vector&lt;unsigned char&gt; message;

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiout-&gt;<a class="code" href="classRtMidiOut.html#a5">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">"No ports available!\n"</span>;
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// Open first available port.</span>
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a2">openPort</a>( 0 );

  <span class="comment">// Send out a series of MIDI messages.</span>

  <span class="comment">// Program change: 192, 5</span>
  message.push_back( 192 );
  message.push_back( 5 );
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a7">sendMessage</a>( &amp;message );

  <span class="comment">// Control Change: 176, 7, 100 (volume)</span>
  message[0] = 176;
  message[1] = 7;
  message.push_back( 100 );
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a7">sendMessage</a>( &amp;message );

  <span class="comment">// Note On: 144, 64, 90</span>
  message[0] = 144;
  message[1] = 64;
  message[2] = 90;
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a7">sendMessage</a>( &amp;message );

  SLEEP( 500 ); <span class="comment">// Platform-dependent ... see example in tests directory.</span>

  <span class="comment">// Note Off: 128, 64, 40</span>
  message[0] = 128;
  message[1] = 64;
  message[2] = 40;
  midiout-&gt;<a class="code" href="classRtMidiOut.html#a7">sendMessage</a>( &amp;message );

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiout;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" name="input">
MIDI Input</a></h2>
The <a class="el" href="classRtMidiIn.html">RtMidiIn</a> class uses an internal callback function or thread to receive incoming MIDI messages from a port or device. These messages are then either queued and read by the user via calls to the <a class="el" href="classRtMidiIn.html#a11">RtMidiIn::getMessage()</a> function or immediately passed to a user-specified callback function (which must be "registered" using the <a class="el" href="classRtMidiIn.html#a4">RtMidiIn::setCallback()</a> function). We'll provide examples of both usages.<p>
The <a class="el" href="classRtMidiIn.html">RtMidiIn</a> class provides the <a class="el" href="classRtMidiIn.html#a10">RtMidiIn::ignoreTypes()</a> function to specify that certain MIDI message types be ignored. By default, sysem exclusive, timing, and active sensing messages are ignored.<h3><a class="anchor" name="qmidiin">
Queued MIDI Input</a></h3>
The <a class="el" href="classRtMidiIn.html#a11">RtMidiIn::getMessage()</a> function does not block. If a MIDI message is available in the queue, it is copied to the user-provided <code>std::vector&lt;unsigned char&gt;</code> container. When no MIDI message is available, the function returns an empty container. The default maximum MIDI queue size is 1024 messages. This value may be modified with the <a class="el" href="classRtMidiIn.html#a9">RtMidiIn::setQueueSizeLimit()</a> function. If the maximum queue size limit is reached, subsequent incoming MIDI messages are discarded until the queue size is reduced.<p>
In the following example, we omit some necessary error checking and details regarding OS-dependent sleep functions. For a more complete example, see the <code>qmidiin.cpp</code> program in the <code>tests</code> directory.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// qmidiin.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include "RtMidi.h"</span>

<span class="keywordtype">bool</span> done;
<span class="keyword">static</span> <span class="keywordtype">void</span> finish(<span class="keywordtype">int</span> ignore){ done = <span class="keyword">true</span>; }

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html">RtMidiIn</a> *midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html">RtMidiIn</a>();
  std::vector&lt;unsigned char&gt; message;
  <span class="keywordtype">int</span> nBytes, i;
  <span class="keywordtype">double</span> stamp;

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a7">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">"No ports available!\n"</span>;
    <span class="keywordflow">goto</span> cleanup;
  }
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a2">openPort</a>( 0 );

  <span class="comment">// Don't ignore sysex, timing, or active sensing messages.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a10">ignoreTypes</a>( <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> );

  <span class="comment">// Install an interrupt handler function.</span>
  done = <span class="keyword">false</span>;
  (void) signal(SIGINT, finish);

  <span class="comment">// Periodically check input queue.</span>
  std::cout &lt;&lt; <span class="stringliteral">"Reading MIDI from port ... quit with Ctrl-C.\n"</span>;
  <span class="keywordflow">while</span> ( !done ) {
    stamp = midiin-&gt;<a class="code" href="classRtMidiIn.html#a11">getMessage</a>( &amp;message );
    nBytes = message.size();
    <span class="keywordflow">for</span> ( i=0; i&lt;nBytes; i++ )
      std::cout &lt;&lt; <span class="stringliteral">"Byte "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; (int)message[i] &lt;&lt; <span class="stringliteral">", "</span>;
    <span class="keywordflow">if</span> ( nBytes &gt; 0 )
      std::cout &lt;&lt; <span class="stringliteral">"stamp = "</span> &lt;&lt; stamp &lt;&lt; <span class="charliteral">'\n'</span>;

    <span class="comment">// Sleep for 10 milliseconds ... platform-dependent.</span>
    SLEEP( 10 );
  }

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="cmidiin">
MIDI Input with User Callback</a></h3>
When set, a user-provided callback function will be invoked after the input of a complete MIDI message. It is possible to provide a pointer to user data which can be accessed in the callback function (not shown here). It is necessary to set the callback function immediately after opening the port to avoid having incoming messages written to the queue (which is not emptied when a callback function is set). If you are worried about this happening, you can check the queue using the RtMidi::getMessage() function to verify it is empty (after the callback function is set).<p>
In the following example, we omit some necessary error checking. For a more complete example, see the <code>cmidiin.cpp</code> program in the <code>tests</code> directory.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// cmidiin.cpp</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "RtMidi.h"</span>

<span class="keywordtype">void</span> mycallback( <span class="keywordtype">double</span> deltatime, std::vector&lt; unsigned char &gt; *message, <span class="keywordtype">void</span> *userData )
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBytes = message-&gt;size();
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nBytes; i++ )
    std::cout &lt;&lt; <span class="stringliteral">"Byte "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; (int)message-&gt;at(i) &lt;&lt; <span class="stringliteral">", "</span>;
  <span class="keywordflow">if</span> ( nBytes &gt; 0 )
    std::cout &lt;&lt; <span class="stringliteral">"stamp = "</span> &lt;&lt; deltatime &lt;&lt; <span class="charliteral">'\n'</span>;
}

<span class="keywordtype">int</span> main()
{
  <a class="code" href="classRtMidiIn.html">RtMidiIn</a> *midiin = <span class="keyword">new</span> <a class="code" href="classRtMidiIn.html">RtMidiIn</a>();

  <span class="comment">// Check available ports.</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPorts = midiin-&gt;<a class="code" href="classRtMidiIn.html#a7">getPortCount</a>();
  <span class="keywordflow">if</span> ( nPorts == 0 ) {
    std::cout &lt;&lt; <span class="stringliteral">"No ports available!\n"</span>;
    <span class="keywordflow">goto</span> cleanup;
  }

  midiin-&gt;<a class="code" href="classRtMidiIn.html#a2">openPort</a>( 0 );

  <span class="comment">// Set our callback function.  This should be done immediately after</span>
  <span class="comment">// opening the port to avoid having incoming messages written to the</span>
  <span class="comment">// queue.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a4">setCallback</a>( &amp;mycallback );

  <span class="comment">// Don't ignore sysex, timing, or active sensing messages.</span>
  midiin-&gt;<a class="code" href="classRtMidiIn.html#a10">ignoreTypes</a>( <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span> );

  std::cout &lt;&lt; <span class="stringliteral">"\nReading MIDI input ... press &lt;enter&gt; to quit.\n"</span>;
  <span class="keywordtype">char</span> input;
  std::cin.get(input);

  <span class="comment">// Clean up</span>
 cleanup:
  <span class="keyword">delete</span> midiin;

  <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" name="virtual">
Virtual Ports</a></h2>
The Linux ALSA and Macintosh CoreMIDI APIs allow for the establishment of virtual input and output MIDI ports to which other software clients can connect. <a class="el" href="classRtMidi.html">RtMidi</a> incorporates this functionality with the <a class="el" href="classRtMidiIn.html#a3">RtMidiIn::openVirtualPort()</a> and <a class="el" href="classRtMidiOut.html#a4">RtMidiOut::openVirtualPort()</a> functions. Any messages sent with the <a class="el" href="classRtMidiOut.html#a7">RtMidiOut::sendMessage()</a> function will also be transmitted through an open virtual output port. If a virtual input port is open and a user callback function is set, the callback function will be invoked when messages arrive via that port. If a callback function is not set, the user must poll the input queue to check whether messages have arrived. No notification is provided for the establishment of a client connection via a virtual port.<h2><a class="anchor" name="compiling">
Compiling</a></h2>
In order to compile <a class="el" href="classRtMidi.html">RtMidi</a> for a specific OS and API, it is necessary to supply the appropriate preprocessor definition and library within the compiler statement: <p>
<table border="2" cols="5" width="100%" cellspacing="3" cellpadding="3">
<tr bgcolor="beige">
<td width="5%"><b>OS:</b> </td><td width="5%"><b>MIDI API:</b> </td><td width="5%"><b>Preprocessor Definition:</b> </td><td width="5%"><b>Library or Framework:</b> </td><td><b>Example Compiler Statement:</b>  </td></tr>
<tr>
<td>Linux </td><td>ALSA Sequencer </td><td>__LINUX_ALSASEQ__ </td><td><code>asound, pthread</code> </td><td><code>g++ -Wall -D__LINUX_ALSASEQ__ -o midiinfo midiinfo.cpp RtMidi.cpp -lasound -lpthread</code>  </td></tr>
<tr>
<td>Macintosh OS X </td><td>CoreMidi </td><td>__MACOSX_CORE__ </td><td><code>CoreMidi, CoreAudio, CoreFoundation</code> </td><td><code>g++ -Wall -D__MACOSX_CORE__ -o midiinfo midiinfo.cpp RtMidi.cpp -framework CoreMidi -framework CoreAudio -framework CoreFoundation</code>  </td></tr>
<tr>
<td>Irix </td><td>MD </td><td>__IRIX_MD__ </td><td><code>md, pthread</code> </td><td><code>CC -Wall -D__IRIX_MD__ -o midiinfo midiinfo.cpp RtMidi.cpp -laudio -lpthread</code>  </td></tr>
<tr>
<td>Windows </td><td>Multimedia Library </td><td>__WINDOWS_MM__ </td><td><code>winmm.lib, multithreaded</code> </td><td><em>compiler specific</em>  </td></tr>
</table>
<p>
The example compiler statements above could be used to compile the <code>probe.cpp</code> example file, assuming that <code>midiinfo.cpp</code>, <code><a class="el" href="RtMidi_8h-source.html">RtMidi.h</a></code>, <code><a class="el" href="RtError_8h-source.html">RtError.h</a></code>, and <code>RtMidi.cpp</code> all exist in the same directory.<h2><a class="anchor" name="debug">
Debugging</a></h2>
If you are having problems getting <a class="el" href="classRtMidi.html">RtMidi</a> to run on your system, try passing the preprocessor definition <code>__RTMIDI_DEBUG__</code> to the compiler (or uncomment the definition at the bottom of <a class="el" href="RtMidi_8h-source.html">RtMidi.h</a>). A variety of warning messages will be displayed which may help in determining the problem. Also try using the programs included in the <code>test</code> directory. The program <code>midiinfo</code> displays the queried capabilities of all MIDI ports found.<h2><a class="anchor" name="apinotes">
API Notes</a></h2>
<a class="el" href="classRtMidi.html">RtMidi</a> is designed to provide a common API across the various supported operating systems and audio libraries. Despite that, some issues should be mentioned with regard to each.<h3><a class="anchor" name="linux">
Linux:</a></h3>
<a class="el" href="classRtMidi.html">RtMidi</a> for Linux was developed using the Fedora distribution. A decision was made to not include support for the OSS API because the OSS API provides such limited functionality and because <a href="http://www.alsa-project.org/">ALSA</a> support is now incorporated in the Linux kernel. <a class="el" href="classRtMidi.html">RtMidi</a> uses the ALSA sequencer API, which allows for virtual software input and output ports.<h3><a class="anchor" name="macosx">
Macintosh OS X (CoreAudio):</a></h3>
The Apple CoreMidi API allows for the establishment of virtual input and output ports to which other software applications can connect.<h3><a class="anchor" name="irix">
Irix (SGI):</a></h3>
The Irix version of <a class="el" href="classRtMidi.html">RtMidi</a> was written and tested on an SGI Indy running Irix version 6.5.4 and the MD audio library.<h3><a class="anchor" name="windowsds">
Windows (Multimedia Library):</a></h3>
The Windows Multimedia library MIDI calls used in <a class="el" href="classRtMidi.html">RtMidi</a> do not make use of streaming functionality. <a class="el" href="classRtMidi.html">RtMidi</a> was originally developed with Visual C++ version 6.0.<h2><a class="anchor" name="acknowledge">
Acknowledgements</a></h2>
Many thanks to the following people for providing bug fixes: <ul>
<li>
Pedro Lopez-Cabanillas (ALSA sequencer API) </li>
<li>
Eduardo Coutinho (Windows device names) </li>
<li>
Jean-Baptiste Berruchon (Windows sysex code) </li>
</ul>
<h2><a class="anchor" name="license">
License</a></h2>
<a class="el" href="classRtMidi.html">RtMidi</a>: realtime MIDI i/o C++ classes<br>
 Copyright (c) 2003-2006 Gary P. Scavone<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:<p>
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.<p>
Any person wishing to distribute modifications to the Software is requested to send the modifications to the original developer so that they can be incorporated into the canonical version.<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. <HR>

<table><tr><td><img src="../images/mcgill.gif" width=165></td>
  <td>&copy;2003-2006 Gary P. Scavone, McGill University. All Rights Reserved.<br>
  Maintained by Gary P. Scavone, gary at music.mcgill.ca</td></tr>
</table>

</BODY>
</HTML>
